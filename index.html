<canvas id="mainCanvas">

</canvas>
<script>
  function copy(a) {

    return JSON.parse(JSON.stringify(a))

  }

  function polygon(x, y, radius, sides, angle) {
    var crd = [];
    angle = angle + 180 // Make the shape upside up by default

    for (var i = 0; i < sides; i++) {
      crd.push([
        (x + (Math.sin(angle + (2 * Math.PI * i / sides)) * radius)),
        (y - (Math.cos(angle + (2 * Math.PI * i / sides)) * radius)),
      ]);
    }
    return crd;
  }

  function createRegularPolygonvertices(x,y,sides, circumradius, angle) {

    var vertices = [];
    var x;
    var result = [];


    vertices = polygon(x, y, circumradius, sides, angle)

    // We will be creating a triangle fan
    // The idea is that at every pair of vertices,
    // we will connect them back to the first vertice
    // to form a triangle
    for (x = 1; x < vertices.length; x++) {
    
      // x coord
      result.push(copy(vertices[x][0]))
      // y coord
      result.push(copy(vertices[x][1]))

      if (x < vertices.length - 1) {
        // x1 coord
        result.push(copy(vertices[x + 1][0]))
        // y1 coord
        result.push(copy(vertices[x + 1][1]))
      } else {
      	// The last one should end up in the beginning again
        
        // x coord
        result.push(copy(vertices[0][0]))
        // y coord
        result.push(copy(vertices[0][1]))
      }

      // first vertice x coord
      result.push(copy(vertices[0][0]))
      // first vertice y coord
      result.push(copy(vertices[0][1]))
    }

    return result
  }

  function main() {
    // Configure the canvas to use WebGL
    //
    var gl;
    var canvas = document.getElementById('mainCanvas');
    try {
      gl = canvas.getContext('webgl');
    } catch (e) {
      throw new Error('no WebGL found');
    }

    // Copy an array of data points forming a triangle to the
    // graphics hardware
    //

    var vertices = createRegularPolygonvertices(0.5,0.5,7, 0.5,90)
    console.log(vertices)

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Create a simple vertex shader
    //
    var vertCode =
      'attribute vec2 coordinates;' +
      'void main(void) {' +
      '  gl_Position = vec4(coordinates, 0.0, 1.0);' +
      '}';

    var vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, vertCode);
    gl.compileShader(vertShader);
    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(vertShader));

    // Create a simple fragment shader
    //
    var fragCode =
      'void main(void) {' +
      '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);' +
      '}';

    var fragCode1 =
      'void main(void) {' +
      '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);' +
      '}';

    var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fragCode);
    gl.compileShader(fragShader);
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(fragShader));

    // Put the vertex shader and fragment shader together into
    // a complete program
    //
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertShader);
    gl.attachShader(shaderProgram, fragShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
      throw new Error(gl.getProgramInfoLog(shaderProgram));

    // Everything we need has now been copied to the graphics
    // hardware, so we can start drawing

    // Clear the drawing surface
    //
    gl.clearColor(1.0, .90, 1.0, .75);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Tell WebGL which shader program to use
    //
    gl.useProgram(shaderProgram);

    // Tell WebGL that the data from the array of triangle
    // coordinates that we've already copied to the graphics
    // hardware should be fed to the vertex shader as the
    // parameter "coordinates"
    //
    var coordinatesVar = gl.getAttribLocation(shaderProgram, "coordinates");
    gl.enableVertexAttribArray(coordinatesVar);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(coordinatesVar, 2, gl.FLOAT, false, 0, 0);

    // Now we can tell WebGL to draw the 3 points that make 
    // up the triangle
    //

    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);

  }

  main();

</script>
<style>
  canvas {
    width: 400;
    height: 400;
  }

</style>

