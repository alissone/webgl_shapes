<canvas id="mainCanvas">

</canvas>
<script>
  function copy(a) {

    return JSON.parse(JSON.stringify(a))

  }

  /* GIVEN x and y (the center coordinates), the radius and the number of polygon sides RETURNS AN ARRAY OF VERTICE COORDINATES */
  function polygon(x, y, radius, sides) {
    var crd = [];
    var angle=6

    /* 1 SIDE CASE */
    if (sides == 1)
      return [
        [x, y]
      ];

    /* > 1 SIDE CASEs */
    for (var i = 0; i < sides; i++) {
      crd.push([(x + (Math.sin(angle + 2 * Math.PI * i / sides) * radius)), (y - (Math.cos(angle + 2 * Math.PI * i / sides) * radius))]);
    }
    return crd;
  }
  
  function geometricMean(x1,y1,x2,y2) {
  return [(x1+x2)/2, (y1+y2)/2]
  }

  function createRegularPolygonvertices(n, circumradius) {

    var vertices = [];
    var x;
    var result = [];

    // Generate the vertices of the n-gon.
    /*  for (x = 1; x <= n; x++) {
           vertices.push(circumradius * Math.sin((Math.PI / n) + (x * ((2 * Math.PI) / n))));
       vertices.push(circumradius * Math.cos((Math.PI / n) + (x * ((2 * Math.PI) / n))));
       vertices.push(0);
     
     } */

    var centerX = 0;
    var centerY = 0;

    vertices = polygon(centerX, centerY, circumradius, n)
    console.log(vertices)


    // We will be creating a triangle fan
    // The idea is that at every pair of vertices,
    // we will connect them to the first vertice
    // to form a triangle
    for (x = 1; x < vertices.length; x++) {
      // x coord
      result.push(copy(vertices[x][0]))
      // y coord
      result.push(copy(vertices[x][1]))

if (x < vertices.length - 1) {
      // x1 coord
      result.push(copy(vertices[x + 1][0]))
      // y1 coord
      result.push(copy(vertices[x + 1][1]))
} else {
      // x coord
      result.push(copy(vertices[0][0]))
      // y coord
      result.push(copy(vertices[0][1]))
}

      //if (x % 2 == 0) {
        // first vertice

        /* result.push(centerX) */
        /* result.push(centerY) */
			result.push(copy(vertices[0][0]))
      // y coord
      result.push(copy(vertices[0][1]))
//      }


    }

    return result
  }

  function main() {
    // Configure the canvas to use WebGL
    //
    var gl;
    var canvas = document.getElementById('mainCanvas');
    try {
      gl = canvas.getContext('webgl');
    } catch (e) {
      throw new Error('no WebGL found');
    }

    // Copy an array of data points forming a triangle to the
    // graphics hardware
    //

    var vertices = createRegularPolygonvertices(7, 0.5)
    console.log(vertices)

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Create a simple vertex shader
    //
    var vertCode =
      'attribute vec2 coordinates;' +
      'void main(void) {' +
      '  gl_Position = vec4(coordinates, 0.0, 1.0);' +
      '}';

    var vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, vertCode);
    gl.compileShader(vertShader);
    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(vertShader));

    // Create a simple fragment shader
    //
    var fragCode =
      'void main(void) {' +
      '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);' +
      '}';

    var fragCode1 =
      'void main(void) {' +
      '   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);' +
      '}';

    var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fragCode);
    gl.compileShader(fragShader);
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(fragShader));

    // Put the vertex shader and fragment shader together into
    // a complete program
    //
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertShader);
    gl.attachShader(shaderProgram, fragShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
      throw new Error(gl.getProgramInfoLog(shaderProgram));

    // Everything we need has now been copied to the graphics
    // hardware, so we can start drawing

    // Clear the drawing surface
    //
    gl.clearColor(1.0, .90, 1.0, .75);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Tell WebGL which shader program to use
    //
    gl.useProgram(shaderProgram);

    // Tell WebGL that the data from the array of triangle
    // coordinates that we've already copied to the graphics
    // hardware should be fed to the vertex shader as the
    // parameter "coordinates"
    //
    var coordinatesVar = gl.getAttribLocation(shaderProgram, "coordinates");
    gl.enableVertexAttribArray(coordinatesVar);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(coordinatesVar, 2, gl.FLOAT, false, 0, 0);

    // Now we can tell WebGL to draw the 3 points that make 
    // up the triangle
    //

    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);

  }

  main();

</script>
<style>
  canvas {
    width: 400;
    height: 400;
  }

</style>

